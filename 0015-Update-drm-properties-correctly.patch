From 2e4fe1cc22c0d681ad3d37cddee09a1b7700101d Mon Sep 17 00:00:00 2001
From: Jonathon Jongsma <jjongsma@redhat.com>
Date: Thu, 6 Nov 2014 15:40:59 -0600
Subject: [PATCH] Update drm properties correctly

When connector properties got changed, those changes were not being
propagated to user-space. This pushes those changes up so that e.g. new
"suggested X|Y" properties can be used to help lay out multiple displays
properly. This code is based on similar code from the nouveau driver.
---
 src/qxl_drmmode.c | 48 +++++++++++++++++++++++++++++++++++++++++++++++-
 src/qxl_drmmode.h |  1 +
 2 files changed, 48 insertions(+), 1 deletion(-)

diff --git a/src/qxl_drmmode.c b/src/qxl_drmmode.c
index 2ef6ba1..43708de 100644
--- a/src/qxl_drmmode.c
+++ b/src/qxl_drmmode.c
@@ -520,6 +520,7 @@ drmmode_output_create_resources(xf86OutputPtr output)
 	    drmModeFreeProperty(drmmode_prop);
 	    continue;
 	}
+	drmmode_output->props[j].index = i;
 	drmmode_output->props[j].mode_prop = drmmode_prop;
 	drmmode_output->props[j].value = mode_output->prop_values[i];
 	drmmode_output->num_props++;
@@ -639,7 +640,52 @@ drmmode_output_set_property(xf86OutputPtr output, Atom property,
 static Bool
 drmmode_output_get_property(xf86OutputPtr output, Atom property)
 {
-    return TRUE;
+    drmmode_output_private_ptr drmmode_output = output->driver_private;
+    drmmode_ptr drmmode = drmmode_output->drmmode;
+    uint32_t value;
+    int err, i;
+
+    if (output->scrn->vtSema) {
+	drmModeFreeConnector(drmmode_output->mode_output);
+	drmmode_output->mode_output =
+	    drmModeGetConnector(drmmode->fd, drmmode_output->output_id);
+    }
+
+    if (!drmmode_output->mode_output)
+	return FALSE;
+
+    for (i = 0; i < drmmode_output->num_props; i++) {
+	drmmode_prop_ptr p = &drmmode_output->props[i];
+	if (p->atoms[0] != property)
+	    continue;
+
+	value = drmmode_output->mode_output->prop_values[p->index];
+
+	if (p->mode_prop->flags & DRM_MODE_PROP_RANGE) {
+	    err = RRChangeOutputProperty(output->randr_output,
+					 property, XA_INTEGER, 32,
+					 PropModeReplace, 1, &value,
+					 FALSE, FALSE);
+
+	    return !err;
+	} else if (p->mode_prop->flags & DRM_MODE_PROP_ENUM) {
+	    int j;
+
+	    /* search for matching name string, then set its value down */
+	    for (j = 0; j < p->mode_prop->count_enums; j++) {
+		if (p->mode_prop->enums[j].value == value)
+		    break;
+	    }
+
+	    err = RRChangeOutputProperty(output->randr_output, property,
+					 XA_ATOM, 32, PropModeReplace, 1,
+					 &p->atoms[j+1], FALSE, FALSE);
+
+	    return !err;
+	}
+    }
+
+    return FALSE;
 }
 
 static const xf86OutputFuncsRec drmmode_output_funcs = {
diff --git a/src/qxl_drmmode.h b/src/qxl_drmmode.h
index 04752ec..392b1e2 100644
--- a/src/qxl_drmmode.h
+++ b/src/qxl_drmmode.h
@@ -69,6 +69,7 @@ typedef struct {
     uint64_t value;
     int num_atoms; /* if range prop, num_atoms == 1; if enum prop, num_atoms == num_enums + 1 */
     Atom *atoms;
+    int index; /* index within the kernel-size property array */
 } drmmode_prop_rec, *drmmode_prop_ptr;
 
 typedef struct {
-- 
2.1.0

